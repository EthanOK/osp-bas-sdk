{"version":3,"file":"index.module.js","sources":["../src/schema/register.ts","../src/attestation/createAttestation.ts","../src/greenfield/utils.ts","../src/greenfield/create.ts","../src/bas/index.ts"],"sourcesContent":["// import {BAS, SchemaRegistry} from \"@bnb-attestation-service/bas-sdk\";\nimport { EAS, SchemaRegistry,SchemaRecord } from \"@ethereum-attestation-service/eas-sdk\";\nimport { ethers, Provider, Signer } from \"ethers\";\nimport { BNB_basAddress, GFTESTCHAINID, GFTESTRPC } from \"../../tests/config\";\n\n\nexport const initEAS = (provider: any, BASContractAddress: string) => {\n  const bas = new EAS(BASContractAddress);\n  bas.connect(provider);\n};\n\n/**\n * Register a schema Parameters\n * @param schema The schema string\n * @param resolverAddress The address of the resolver\n * @param revocable Whether the schema is revocable\n */\nexport type RegisterSchemaParams = {\n  schema: string;\n  resolverAddress?: string;\n  revocable?: boolean;\n};\n\n/**\n * Register a schema on the Schema Registry\n * @param signer The signer object\n * @param schemaRegistryAddress The address of the Schema Registry\n * @param params The parameters for the schema\n * @returns The UID of the registered schema\n */\nexport const registerSchema = async (\n  signer: Signer,\n  schemaRegistryAddress: string,\n  params: RegisterSchemaParams\n) => {\n  const schemaRegistry = new SchemaRegistry(schemaRegistryAddress);\n\n  schemaRegistry.connect(signer);\n\n  const transaction = await schemaRegistry.register({\n    schema: params.schema,\n    resolverAddress: params.resolverAddress,\n    revocable: params.revocable,\n  });\n\n  // Optional: Wait for transaction to be validated\n  const schemaUID = await transaction.wait();\n  return schemaUID;\n};\n\n/**\n * Get a schema by its UID\n * @param provider The provider object\n * @param schemaRegistryAddress The address of the Schema Registry\n * @param schemaUID The UID of the schema\n * @returns The schema record\n */\nexport const getSchemaByUID = async (\n  provider: Provider,\n  schemaRegistryAddress: string,\n  schemaUID: string\n):Promise<SchemaRecord> => {\n  const schemaRegistry = new SchemaRegistry(schemaRegistryAddress);\n  schemaRegistry.connect(provider);\n\n  const schemaRecord = await schemaRegistry.getSchema({ uid: schemaUID });\n\n  return schemaRecord;\n};\n","// import { SchemaEncoder, BAS } from \"@bnb-attestation-service/bas-sdk\";\nimport { EAS, SchemaEncoder } from \"@ethereum-attestation-service/eas-sdk\";\nimport { ethers, Signer } from \"ethers\";\nimport { BNB_schemaRegistryAddress } from \"../../tests/config\";\nimport { getSchemaByUID } from \"../schema/register\";\n\n// Initialize SchemaEncoder with the schema string\n\n/**\n * Attestation params\n * @param schemaUID schema uid\n * @param encodedData encoded data\n * @param refUID reference uid\n * @param recipient recipient address\n */\nexport type AttestParams = {\n  schemaUID: string;\n  encodedData: string;\n  refUID: string;\n  recipient: string;\n};\n\n/**\n * Create attestation\n * @param signer signer\n * @param bas bas\n * @param params attestation params\n * @returns attestation string\n */\nexport const createAttestOffChain = async (\n  signer: Signer,\n  bas: EAS,\n  params: AttestParams\n) => {\n  bas.connect(signer);\n\n  const offchain = await bas.getOffchain();\n\n  // const schema = await getSchemaByUID(\n  //   signer.provider,\n  //   BNB_schemaRegistryAddress,\n  //   params.schemaUID\n  // );\n  // console.log(schema);\n\n  const timestamp = Math.floor(Date.now() / 1000);\n\n  const attestation = await offchain.signOffchainAttestation(\n    {\n      recipient: params.recipient,\n      // Unix timestamp of when attestation expires. (0 for no expiration)\n      expirationTime: BigInt(0),\n      // Unix timestamp of current time\n      time: BigInt(timestamp),\n      revocable: true,\n      version: 1, // Fixed value\n      nonce: BigInt(0), // Fixed value\n      schema: params.schemaUID,\n      refUID: params.refUID,\n      data: params.encodedData,\n    },\n    signer\n  );\n\n  const attestation_ = JSON.stringify(attestation, (key, value) =>\n    typeof value === \"bigint\" ? Number(value).toString() : value\n  );\n\n  return attestation_;\n};\n","import { hashMessage, getAddress } from \"ethers\";\n\n/**\n * encode address to bucket name\n * @param addr\n * @returns bucket name\n */\nexport const encodeAddrToBucketName = (addr: string) => {\n  return `bas-${hashMessage(getAddress(addr)).substring(2, 42)}`;\n};\nexport const getSps = async (client) => {\n  const sps = await client.sp.getStorageProviders();\n  const finalSps = (sps ?? []).filter((v) => v.endpoint.includes(\"nodereal\"));\n  return finalSps;\n};\nexport const getAllSps = async (client) => {\n  const sps = await getSps(client);\n  return sps.map((sp) => {\n    return {\n      address: sp.operatorAddress,\n      endpoint: sp.endpoint,\n      name: sp.description?.moniker,\n    };\n  });\n};\nexport const selectSp = async (client) => {\n  const finalSps = await getSps(client);\n  const selectIndex = Math.floor(Math.random() * finalSps.length);\n  const secondarySpAddresses = [\n    ...finalSps.slice(0, selectIndex),\n    ...finalSps.slice(selectIndex + 1),\n  ].map((item) => item.operatorAddress);\n  const selectSpInfo = {\n    //@ts-ignore\n    id: finalSps[selectIndex].id || 0,\n    endpoint: finalSps[selectIndex].endpoint,\n    primarySpAddress: finalSps[selectIndex]?.operatorAddress,\n    sealAddress: finalSps[selectIndex].sealAddress,\n    secondarySpAddresses,\n  };\n  return selectSpInfo;\n};\n","import {\n  bytesFromBase64,\n  Client,\n  Long,\n  RedundancyType,\n  VisibilityType,\n} from \"@bnb-chain/greenfield-js-sdk\";\nimport { DeliverTxResponse } from \"@cosmjs/stargate\";\nimport { encodeAddrToBucketName, selectSp } from \"./utils\";\nimport { ReedSolomon } from \"@bnb-chain/reed-solomon\";\n// import { NodeAdapterReedSolomon } from \"@bnb-chain/reed-solomon/node.adapter\";\n\nconst rs = new ReedSolomon();\n// const rs = new NodeAdapterReedSolomon();\n\n/**\n * GreenField Client\n */\nexport class GreenFieldClientTS {\n  client: Client;\n  // chainId = null;\n  address = null;\n  /**\n   * @param url greenfield rpc url\n   * @param chainId greenfield chainId\n   * @param creator creator address\n   */\n  constructor(url: string, chainId: string, creator: string) {\n    this.client = Client.create(url, chainId);\n    this.address = creator;\n  }\n\n  /**\n   * create bucket\n   * @param bucketName bucket name\n   * @param privateKey creator private key\n   */\n  async createBucket(bucketName: string, privateKey: string) {\n    const spInfo = await selectSp(this.client);\n    // console.log(\"spInfo\", spInfo);\n\n    if (!privateKey.startsWith(\"0x\")) {\n      privateKey = \"0x\" + privateKey;\n    }\n\n    // Bucket is existed\n    let isBucketExist = false;\n    try {\n      const bucketMeta = await this.client.bucket.getBucketMeta({ bucketName });\n      console.log(\"bucketMeta\", bucketMeta);\n\n      isBucketExist = true;\n    } catch (error) {}\n\n    let res: DeliverTxResponse;\n    try {\n      const createBucketTx = await this.client.bucket.createBucket({\n        bucketName: bucketName,\n        creator: this.address,\n        visibility: VisibilityType.VISIBILITY_TYPE_PUBLIC_READ,\n        chargedReadQuota: Long.fromString(\"0\"),\n        paymentAddress: this.address,\n        primarySpAddress: spInfo.primarySpAddress,\n      });\n      // console.log({ createBucketTx });\n\n      const simulateInfo = await createBucketTx.simulate({\n        denom: \"BNB\",\n      });\n      // console.log(\"simulateInfo\", simulateInfo);\n      res = await createBucketTx.broadcast({\n        denom: \"BNB\",\n        gasLimit: Number(simulateInfo?.gasLimit),\n        gasPrice: simulateInfo?.gasPrice || \"5000000000\",\n        payer: this.address,\n        granter: \"\",\n        privateKey: privateKey,\n      });\n\n      console.log(\"transactionHash\", res.transactionHash);\n    } catch (error) {\n      if (!isBucketExist) {\n        console.log(error);\n      }\n    }\n\n    return isBucketExist;\n  }\n\n  /**\n   * create object\n   * @param bucketName bucket name\n   * @param attestation attestation\n   * @param privateKey creator private key\n   * @param isPrivate is private object\n   */\n  async createObject(\n    bucketName: string,\n    attestation: string,\n    privateKey: string,\n    isPrivate = false\n  ) {\n    console.log(\"started\");\n    // console.log(this.address, this.chainId);\n    if (!privateKey.startsWith(\"0x\")) {\n      privateKey = \"0x\" + privateKey;\n    }\n\n    const attest = JSON.parse(attestation);\n    const fileName = `${attest.message.schema}.${attest.uid}`;\n\n    const fileBuffer = Buffer.from(attestation);\n\n    const expectCheckSums = rs.encode(Uint8Array.from(fileBuffer));\n    // const expectCheckSums = await rs.encodeInWorker(\n    //   __filename,\n    //   Uint8Array.from(fileBuffer)\n    // );\n\n    // createObject\n    const createObjectTx = await this.client.object.createObject({\n      bucketName: bucketName,\n      objectName: fileName,\n      creator: this.address,\n      visibility: isPrivate\n        ? VisibilityType.VISIBILITY_TYPE_PRIVATE\n        : VisibilityType.VISIBILITY_TYPE_PUBLIC_READ,\n      contentType: \"json\",\n      redundancyType: RedundancyType.REDUNDANCY_EC_TYPE,\n      payloadSize: Long.fromInt(fileBuffer.byteLength),\n      expectChecksums: expectCheckSums.map((x) => bytesFromBase64(x)),\n    });\n\n    const simulateInfo = await createObjectTx.simulate({\n      denom: \"BNB\",\n    });\n    // console.log(simulateInfo);\n    const { transactionHash } = await createObjectTx.broadcast({\n      denom: \"BNB\",\n      gasLimit: Number(simulateInfo.gasLimit),\n      gasPrice: simulateInfo.gasPrice,\n      payer: this.address,\n      granter: \"\",\n      privateKey: privateKey,\n    });\n\n    console.log(\"create object success\", transactionHash);\n\n    // uploadObject\n    const uploadRes = await this.client.object.uploadObject(\n      {\n        bucketName: bucketName,\n        objectName: fileName,\n        body: createFile(fileName, fileBuffer),\n        txnHash: transactionHash,\n      },\n      // highlight-start\n      {\n        type: \"ECDSA\",\n        privateKey: privateKey,\n      }\n      // highlight-end\n    );\n    if (uploadRes.code === 0) {\n      console.log(\"upload object success\", uploadRes);\n    }\n\n    return transactionHash;\n  }\n}\nfunction createFile(fileName: string, fileBuffer: Buffer) {\n  return {\n    name: fileName,\n    type: \"\",\n    size: fileBuffer.byteLength,\n    content: fileBuffer,\n  };\n}\n","import {\n  EAS as BaseEAS,\n  SchemaEncoder as BaseSchemaEncoder,\n  MultiAttestationRequest as BaseMultiAttestationRequest,\n  AttestationRequestData as BaseAttestationRequestData,\n} from \"@ethereum-attestation-service/eas-sdk\";\n\nexport const BAS = BaseEAS;\nexport const SchemaEncoder = BaseSchemaEncoder;\nexport type MultiAttestationRequest = BaseMultiAttestationRequest;\nexport type AttestationRequestData = BaseAttestationRequestData;\n"],"names":["initEAS","provider","BASContractAddress","EAS","connect","registerSchema","signer","schemaRegistryAddress","params","schemaRegistry","SchemaRegistry","Promise","resolve","register","schema","resolverAddress","revocable","then","transaction","wait","e","reject","getSchemaByUID","schemaUID","getSchema","uid","createAttestOffChain","bas","getOffchain","offchain","timestamp","Math","floor","Date","now","signOffchainAttestation","recipient","expirationTime","BigInt","time","version","nonce","refUID","data","encodedData","attestation","JSON","stringify","key","value","Number","toString","encodeAddrToBucketName","addr","hashMessage","getAddress","substring","getSps","client","sp","getStorageProviders","sps","filter","v","endpoint","includes","getAllSps","map","_sp$description","address","operatorAddress","name","description","moniker","selectSp","finalSps","_finalSps$selectIndex","selectIndex","random","length","secondarySpAddresses","concat","slice","item","id","primarySpAddress","sealAddress","rs","ReedSolomon","GreenFieldClientTS","url","chainId","creator","this","Client","create","_proto","prototype","createBucket","bucketName","privateKey","_this","spInfo","_temp3","_temp","_catch","bucket","visibility","VisibilityType","VISIBILITY_TYPE_PUBLIC_READ","chargedReadQuota","Long","fromString","paymentAddress","createBucketTx","simulate","denom","simulateInfo","broadcast","gasLimit","gasPrice","payer","granter","_createBucketTx$broad","console","log","transactionHash","error","isBucketExist","startsWith","_temp2","getBucketMeta","bucketMeta","createObject","isPrivate","_this2","attest","parse","fileName","message","fileBuffer","Buffer","from","expectCheckSums","encode","Uint8Array","object","objectName","VISIBILITY_TYPE_PRIVATE","contentType","redundancyType","RedundancyType","REDUNDANCY_EC_TYPE","payloadSize","fromInt","byteLength","expectChecksums","x","bytesFromBase64","createObjectTx","_ref","uploadObject","body","createFile","txnHash","type","uploadRes","code","size","content","BAS","BaseEAS","SchemaEncoder","BaseSchemaEncoder"],"mappings":"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"}
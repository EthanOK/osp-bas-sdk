{"version":3,"file":"index.modern.mjs","sources":["../src/schema/register.ts","../src/attestation/createAttestation.ts","../src/greenfield/utils.ts","../src/greenfield/create.ts"],"sourcesContent":["// import {BAS, SchemaRegistry} from \"@bnb-attestation-service/bas-sdk\";\nimport { EAS, SchemaRegistry,SchemaRecord } from \"@ethereum-attestation-service/eas-sdk\";\nimport { ethers, Provider, Signer } from \"ethers\";\nimport { BNB_basAddress, GFTESTCHAINID, GFTESTRPC } from \"../../tests/config\";\n\n\nexport const initEAS = (provider: any, BASContractAddress: string) => {\n  const bas = new EAS(BASContractAddress);\n  bas.connect(provider);\n};\n\n/**\n * Register a schema Parameters\n * @param schema The schema string\n * @param resolverAddress The address of the resolver\n * @param revocable Whether the schema is revocable\n */\nexport type RegisterSchemaParams = {\n  schema: string;\n  resolverAddress?: string;\n  revocable?: boolean;\n};\n\n/**\n * Register a schema on the Schema Registry\n * @param signer The signer object\n * @param schemaRegistryAddress The address of the Schema Registry\n * @param params The parameters for the schema\n * @returns The UID of the registered schema\n */\nexport const registerSchema = async (\n  signer: Signer,\n  schemaRegistryAddress: string,\n  params: RegisterSchemaParams\n) => {\n  const schemaRegistry = new SchemaRegistry(schemaRegistryAddress);\n\n  schemaRegistry.connect(signer);\n\n  const transaction = await schemaRegistry.register({\n    schema: params.schema,\n    resolverAddress: params.resolverAddress,\n    revocable: params.revocable,\n  });\n\n  // Optional: Wait for transaction to be validated\n  const schemaUID = await transaction.wait();\n  return schemaUID;\n};\n\n/**\n * Get a schema by its UID\n * @param provider The provider object\n * @param schemaRegistryAddress The address of the Schema Registry\n * @param schemaUID The UID of the schema\n * @returns The schema record\n */\nexport const getSchemaByUID = async (\n  provider: Provider,\n  schemaRegistryAddress: string,\n  schemaUID: string\n):Promise<SchemaRecord> => {\n  const schemaRegistry = new SchemaRegistry(schemaRegistryAddress);\n  schemaRegistry.connect(provider);\n\n  const schemaRecord = await schemaRegistry.getSchema({ uid: schemaUID });\n\n  return schemaRecord;\n};\n","// import { SchemaEncoder, BAS } from \"@bnb-attestation-service/bas-sdk\";\nimport { EAS, SchemaEncoder } from \"@ethereum-attestation-service/eas-sdk\";\nimport { ethers, Signer } from \"ethers\";\nimport { BNB_schemaRegistryAddress } from \"../../tests/config\";\nimport { getSchemaByUID } from \"../schema/register\";\n\n// Initialize SchemaEncoder with the schema string\n\n/**\n * Attestation params\n * @param schemaUID schema uid\n * @param encodedData encoded data\n * @param refUID reference uid\n * @param recipient recipient address\n */\nexport type AttestParams = {\n  schemaUID: string;\n  encodedData: string;\n  refUID: string;\n  recipient: string;\n};\n\n/**\n * Create attestation\n * @param signer signer\n * @param bas bas\n * @param params attestation params\n * @returns attestation string\n */\nexport const createAttestOffChain = async (\n  signer: Signer,\n  bas: EAS,\n  params: AttestParams\n) => {\n  bas.connect(signer);\n\n  const offchain = await bas.getOffchain();\n\n  // const schema = await getSchemaByUID(\n  //   signer.provider,\n  //   BNB_schemaRegistryAddress,\n  //   params.schemaUID\n  // );\n  // console.log(schema);\n\n  const timestamp = Math.floor(Date.now() / 1000);\n\n  const attestation = await offchain.signOffchainAttestation(\n    {\n      recipient: params.recipient,\n      // Unix timestamp of when attestation expires. (0 for no expiration)\n      expirationTime: BigInt(0),\n      // Unix timestamp of current time\n      time: BigInt(timestamp),\n      revocable: true,\n      version: 1, // Fixed value\n      nonce: BigInt(0), // Fixed value\n      schema: params.schemaUID,\n      refUID: params.refUID,\n      data: params.encodedData,\n    },\n    signer\n  );\n\n  const attestation_ = JSON.stringify(attestation, (key, value) =>\n    typeof value === \"bigint\" ? Number(value).toString() : value\n  );\n\n  return attestation_;\n};\n","import { hashMessage, getAddress } from \"ethers\";\n\n/**\n * encode address to bucket name\n * @param addr\n * @returns bucket name\n */\nexport const encodeAddrToBucketName = (addr: string) => {\n  return `bas-${hashMessage(getAddress(addr)).substring(2, 42)}`;\n};\nexport const getSps = async (client) => {\n  const sps = await client.sp.getStorageProviders();\n  const finalSps = (sps ?? []).filter((v) => v.endpoint.includes(\"nodereal\"));\n  return finalSps;\n};\nexport const getAllSps = async (client) => {\n  const sps = await getSps(client);\n  return sps.map((sp) => {\n    return {\n      address: sp.operatorAddress,\n      endpoint: sp.endpoint,\n      name: sp.description?.moniker,\n    };\n  });\n};\nexport const selectSp = async (client) => {\n  const finalSps = await getSps(client);\n  const selectIndex = Math.floor(Math.random() * finalSps.length);\n  const secondarySpAddresses = [\n    ...finalSps.slice(0, selectIndex),\n    ...finalSps.slice(selectIndex + 1),\n  ].map((item) => item.operatorAddress);\n  const selectSpInfo = {\n    //@ts-ignore\n    id: finalSps[selectIndex].id || 0,\n    endpoint: finalSps[selectIndex].endpoint,\n    primarySpAddress: finalSps[selectIndex]?.operatorAddress,\n    sealAddress: finalSps[selectIndex].sealAddress,\n    secondarySpAddresses,\n  };\n  return selectSpInfo;\n};\n","import {\n  bytesFromBase64,\n  Client,\n  Long,\n  RedundancyType,\n  VisibilityType,\n} from \"@bnb-chain/greenfield-js-sdk\";\nimport { DeliverTxResponse } from \"@cosmjs/stargate\";\nimport { encodeAddrToBucketName, selectSp } from \"./utils\";\nimport { ReedSolomon } from \"@bnb-chain/reed-solomon\";\n// import { NodeAdapterReedSolomon } from \"@bnb-chain/reed-solomon/node.adapter\";\n\nconst rs = new ReedSolomon();\n// const rs = new NodeAdapterReedSolomon();\n\n/**\n * GreenField Client\n */\nexport class GreenFieldClientTS {\n  client: Client;\n  // chainId = null;\n  address = null;\n  /**\n   * @param url greenfield rpc url\n   * @param chainId greenfield chainId\n   * @param creator creator address\n   */\n  constructor(url: string, chainId: string, creator: string) {\n    this.client = Client.create(url, chainId);\n    this.address = creator;\n  }\n\n  /**\n   * create bucket\n   * @param bucketName bucket name\n   * @param privateKey creator private key\n   */\n  async createBucket(bucketName: string, privateKey: string) {\n    const spInfo = await selectSp(this.client);\n    // console.log(\"spInfo\", spInfo);\n\n    if (!privateKey.startsWith(\"0x\")) {\n      privateKey = \"0x\" + privateKey;\n    }\n\n    // Bucket is existed\n    let isBucketExist = false;\n    try {\n      const bucketMeta = await this.client.bucket.getBucketMeta({ bucketName });\n      console.log(\"bucketMeta\", bucketMeta);\n\n      isBucketExist = true;\n    } catch (error) {}\n\n    let res: DeliverTxResponse;\n    try {\n      const createBucketTx = await this.client.bucket.createBucket({\n        bucketName: bucketName,\n        creator: this.address,\n        visibility: VisibilityType.VISIBILITY_TYPE_PUBLIC_READ,\n        chargedReadQuota: Long.fromString(\"0\"),\n        paymentAddress: this.address,\n        primarySpAddress: spInfo.primarySpAddress,\n      });\n      // console.log({ createBucketTx });\n\n      const simulateInfo = await createBucketTx.simulate({\n        denom: \"BNB\",\n      });\n      // console.log(\"simulateInfo\", simulateInfo);\n      res = await createBucketTx.broadcast({\n        denom: \"BNB\",\n        gasLimit: Number(simulateInfo?.gasLimit),\n        gasPrice: simulateInfo?.gasPrice || \"5000000000\",\n        payer: this.address,\n        granter: \"\",\n        privateKey: privateKey,\n      });\n\n      console.log(\"transactionHash\", res.transactionHash);\n    } catch (error) {\n      if (!isBucketExist) {\n        console.log(error);\n      }\n    }\n\n    return isBucketExist;\n  }\n\n  /**\n   * create object\n   * @param bucketName bucket name\n   * @param attestation attestation\n   * @param privateKey creator private key\n   * @param isPrivate is private object\n   */\n  async createObject(\n    bucketName: string,\n    attestation: string,\n    privateKey: string,\n    isPrivate = false\n  ) {\n    console.log(\"started\");\n    // console.log(this.address, this.chainId);\n    if (!privateKey.startsWith(\"0x\")) {\n      privateKey = \"0x\" + privateKey;\n    }\n\n    const attest = JSON.parse(attestation);\n    const fileName = `${attest.message.schema}.${attest.uid}`;\n\n    const fileBuffer = Buffer.from(attestation);\n\n    const expectCheckSums = rs.encode(Uint8Array.from(fileBuffer));\n    // const expectCheckSums = await rs.encodeInWorker(\n    //   __filename,\n    //   Uint8Array.from(fileBuffer)\n    // );\n\n    // createObject\n    const createObjectTx = await this.client.object.createObject({\n      bucketName: bucketName,\n      objectName: fileName,\n      creator: this.address,\n      visibility: isPrivate\n        ? VisibilityType.VISIBILITY_TYPE_PRIVATE\n        : VisibilityType.VISIBILITY_TYPE_PUBLIC_READ,\n      contentType: \"json\",\n      redundancyType: RedundancyType.REDUNDANCY_EC_TYPE,\n      payloadSize: Long.fromInt(fileBuffer.byteLength),\n      expectChecksums: expectCheckSums.map((x) => bytesFromBase64(x)),\n    });\n\n    const simulateInfo = await createObjectTx.simulate({\n      denom: \"BNB\",\n    });\n    // console.log(simulateInfo);\n    const { transactionHash } = await createObjectTx.broadcast({\n      denom: \"BNB\",\n      gasLimit: Number(simulateInfo.gasLimit),\n      gasPrice: simulateInfo.gasPrice,\n      payer: this.address,\n      granter: \"\",\n      privateKey: privateKey,\n    });\n\n    console.log(\"create object success\", transactionHash);\n\n    // uploadObject\n    const uploadRes = await this.client.object.uploadObject(\n      {\n        bucketName: bucketName,\n        objectName: fileName,\n        body: createFile(fileName, fileBuffer),\n        txnHash: transactionHash,\n      },\n      // highlight-start\n      {\n        type: \"ECDSA\",\n        privateKey: privateKey,\n      }\n      // highlight-end\n    );\n    if (uploadRes.code === 0) {\n      console.log(\"upload object success\", uploadRes);\n    }\n\n    return transactionHash;\n  }\n}\nfunction createFile(fileName: string, fileBuffer: Buffer) {\n  return {\n    name: fileName,\n    type: \"\",\n    size: fileBuffer.byteLength,\n    content: fileBuffer,\n  };\n}\n"],"names":["initEAS","provider","BASContractAddress","EAS","connect","registerSchema","async","signer","schemaRegistryAddress","params","schemaRegistry","SchemaRegistry","transaction","register","schema","resolverAddress","revocable","wait","schemaUID","getSchemaByUID","getSchema","uid","schemaRecord","createAttestOffChain","bas","offchain","getOffchain","timestamp","Math","floor","Date","now","attestation","signOffchainAttestation","recipient","expirationTime","BigInt","time","version","nonce","refUID","data","encodedData","JSON","stringify","key","value","Number","toString","attestation_","encodeAddrToBucketName","addr","hashMessage","getAddress","substring","getSps","sps","client","sp","getStorageProviders","filter","v","endpoint","includes","finalSps","getAllSps","map","_sp$description","address","operatorAddress","name","description","moniker","selectSp","_finalSps$selectIndex","selectIndex","random","length","secondarySpAddresses","slice","item","id","primarySpAddress","sealAddress","selectSpInfo","rs","ReedSolomon","GreenFieldClientTS","constructor","url","chainId","creator","this","Client","create","createBucket","bucketName","privateKey","spInfo","startsWith","res","isBucketExist","bucketMeta","bucket","getBucketMeta","console","log","error","createBucketTx","visibility","VisibilityType","VISIBILITY_TYPE_PUBLIC_READ","chargedReadQuota","Long","fromString","paymentAddress","simulateInfo","simulate","denom","broadcast","gasLimit","gasPrice","payer","granter","transactionHash","createObject","isPrivate","attest","parse","fileName","message","fileBuffer","Buffer","from","expectCheckSums","encode","Uint8Array","createObjectTx","object","objectName","VISIBILITY_TYPE_PRIVATE","contentType","redundancyType","RedundancyType","REDUNDANCY_EC_TYPE","payloadSize","fromInt","byteLength","expectChecksums","x","bytesFromBase64","uploadRes","uploadObject","body","createFile","txnHash","type","code","size","content"],"mappings":"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"}
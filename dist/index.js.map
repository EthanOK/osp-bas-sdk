{"version":3,"file":"index.js","sources":["../src/greenfield/utils.ts","../src/greenfield/create.ts","../src/attestation/createAttestation.ts","../src/schema/register.ts"],"sourcesContent":["import { hashMessage, getAddress } from \"ethers\";\n\n/**\n * @description encode address to bucket name\n * @param addr\n * @returns bucket name\n */\nexport const encodeAddrToBucketName = (addr: string) => {\n  return `bas-${hashMessage(getAddress(addr)).substring(2, 42)}`;\n};\nexport const getSps = async (client) => {\n  const sps = await client.sp.getStorageProviders();\n  const finalSps = (sps ?? []).filter((v) => v.endpoint.includes(\"nodereal\"));\n  return finalSps;\n};\nexport const getAllSps = async (client) => {\n  const sps = await getSps(client);\n  return sps.map((sp) => {\n    return {\n      address: sp.operatorAddress,\n      endpoint: sp.endpoint,\n      name: sp.description?.moniker,\n    };\n  });\n};\nexport const selectSp = async (client) => {\n  const finalSps = await getSps(client);\n  const selectIndex = Math.floor(Math.random() * finalSps.length);\n  const secondarySpAddresses = [\n    ...finalSps.slice(0, selectIndex),\n    ...finalSps.slice(selectIndex + 1),\n  ].map((item) => item.operatorAddress);\n  const selectSpInfo = {\n    //@ts-ignore\n    id: finalSps[selectIndex].id || 0,\n    endpoint: finalSps[selectIndex].endpoint,\n    primarySpAddress: finalSps[selectIndex]?.operatorAddress,\n    sealAddress: finalSps[selectIndex].sealAddress,\n    secondarySpAddresses,\n  };\n  return selectSpInfo;\n};\n","import {\n  bytesFromBase64,\n  Client,\n  Long,\n  RedundancyType,\n  VisibilityType,\n} from \"@bnb-chain/greenfield-js-sdk\";\nimport { DeliverTxResponse } from \"@cosmjs/stargate\";\nimport { encodeAddrToBucketName, selectSp } from \"./utils\";\nimport { ReedSolomon } from \"@bnb-chain/reed-solomon\";\n// import { NodeAdapterReedSolomon } from \"@bnb-chain/reed-solomon/node.adapter\";\n\nconst rs = new ReedSolomon();\n// const rs = new NodeAdapterReedSolomon();\n\n/**\n * GreenField Client\n */\nexport class GreenFieldClientTS {\n  client: Client;\n  // chainId = null;\n  address = null;\n  /**\n   * @param url greenfield rpc url\n   * @param chainId greenfield chainId\n   * @param creator creator address\n   */\n  constructor(url: string, chainId: string, creator: string) {\n    this.client = Client.create(url, chainId);\n    this.address = creator;\n  }\n\n  /**\n   * create bucket\n   * @param bucketName bucket name\n   * @param privateKey creator private key\n   */\n  async createBucket(bucketName: string, privateKey: string) {\n    const spInfo = await selectSp(this.client);\n    // console.log(\"spInfo\", spInfo);\n\n    if (!privateKey.startsWith(\"0x\")) {\n      privateKey = \"0x\" + privateKey;\n    }\n\n    // Bucket is existed\n    let isBucketExist = false;\n    try {\n      const bucketMeta = await this.client.bucket.getBucketMeta({ bucketName });\n      console.log(\"bucketMeta\", bucketMeta);\n\n      isBucketExist = true;\n    } catch (error) {}\n\n    let res: DeliverTxResponse;\n    try {\n      const createBucketTx = await this.client.bucket.createBucket({\n        bucketName: bucketName,\n        creator: this.address,\n        visibility: VisibilityType.VISIBILITY_TYPE_PUBLIC_READ,\n        chargedReadQuota: Long.fromString(\"0\"),\n        paymentAddress: this.address,\n        primarySpAddress: spInfo.primarySpAddress,\n      });\n      // console.log({ createBucketTx });\n\n      const simulateInfo = await createBucketTx.simulate({\n        denom: \"BNB\",\n      });\n      // console.log(\"simulateInfo\", simulateInfo);\n      res = await createBucketTx.broadcast({\n        denom: \"BNB\",\n        gasLimit: Number(simulateInfo?.gasLimit),\n        gasPrice: simulateInfo?.gasPrice || \"5000000000\",\n        payer: this.address,\n        granter: \"\",\n        privateKey: privateKey,\n      });\n\n      console.log(\"transactionHash\", res.transactionHash);\n    } catch (error) {\n      if (!isBucketExist) {\n        console.log(error);\n      }\n    }\n\n    return isBucketExist;\n  }\n\n  /**\n   * create object\n   * @param bucketName bucket name\n   * @param attestation attestation\n   * @param privateKey creator private key\n   * @param isPrivate is private object\n   */\n  async createObject(\n    bucketName: string,\n    attestation: string,\n    privateKey: string,\n    isPrivate = false\n  ) {\n    console.log(\"started\");\n    // console.log(this.address, this.chainId);\n    if (!privateKey.startsWith(\"0x\")) {\n      privateKey = \"0x\" + privateKey;\n    }\n\n    const attest = JSON.parse(attestation);\n    const fileName = `${attest.message.schema}.${attest.uid}`;\n\n    const fileBuffer = Buffer.from(attestation);\n\n    const expectCheckSums = rs.encode(Uint8Array.from(fileBuffer));\n    // const expectCheckSums = await rs.encodeInWorker(\n    //   __filename,\n    //   Uint8Array.from(fileBuffer)\n    // );\n\n    // createObject\n    const createObjectTx = await this.client.object.createObject({\n      bucketName: bucketName,\n      objectName: fileName,\n      creator: this.address,\n      visibility: isPrivate\n        ? VisibilityType.VISIBILITY_TYPE_PRIVATE\n        : VisibilityType.VISIBILITY_TYPE_PUBLIC_READ,\n      contentType: \"json\",\n      redundancyType: RedundancyType.REDUNDANCY_EC_TYPE,\n      payloadSize: Long.fromInt(fileBuffer.byteLength),\n      expectChecksums: expectCheckSums.map((x) => bytesFromBase64(x)),\n    });\n\n    const simulateInfo = await createObjectTx.simulate({\n      denom: \"BNB\",\n    });\n    // console.log(simulateInfo);\n    const { transactionHash } = await createObjectTx.broadcast({\n      denom: \"BNB\",\n      gasLimit: Number(simulateInfo.gasLimit),\n      gasPrice: simulateInfo.gasPrice,\n      payer: this.address,\n      granter: \"\",\n      privateKey: privateKey,\n    });\n\n    console.log(\"create object success\", transactionHash);\n\n    // uploadObject\n    const uploadRes = await this.client.object.uploadObject(\n      {\n        bucketName: bucketName,\n        objectName: fileName,\n        body: createFile(fileName, fileBuffer),\n        txnHash: transactionHash,\n      },\n      // highlight-start\n      {\n        type: \"ECDSA\",\n        privateKey: privateKey,\n      }\n      // highlight-end\n    );\n    if (uploadRes.code === 0) {\n      console.log(\"upload object success\", uploadRes);\n    }\n\n    return transactionHash;\n  }\n}\nfunction createFile(fileName: string, fileBuffer: Buffer) {\n  return {\n    name: fileName,\n    type: \"\",\n    size: fileBuffer.byteLength,\n    content: fileBuffer,\n  };\n}\n","// import { SchemaEncoder, BAS } from \"@bnb-attestation-service/bas-sdk\";\nimport { EAS, SchemaEncoder } from \"@ethereum-attestation-service/eas-sdk\";\nimport { ethers, Signer } from \"ethers\";\nimport { BNB_schemaRegistryAddress } from \"../../tests/config\";\nimport { getSchemaByUID } from \"../schema/register\";\n\n// Initialize SchemaEncoder with the schema string\n\n/**\n * Attestation params\n * @param schemaUID schema uid\n * @param encodedData encoded data\n * @param refUID reference uid\n * @param recipient recipient address\n */\nexport type AttestParams = {\n  schemaUID: string;\n  encodedData: string;\n  refUID: string;\n  recipient: string;\n};\n\n/**\n * Create attestation\n * @param signer signer\n * @param bas bas\n * @param params attestation params\n * @returns attestation string\n */\nexport const createAttestOffChain = async (\n  signer: Signer,\n  bas: EAS,\n  params: AttestParams\n) => {\n  bas.connect(signer);\n\n  const offchain = await bas.getOffchain();\n\n  // const schema = await getSchemaByUID(\n  //   signer.provider,\n  //   BNB_schemaRegistryAddress,\n  //   params.schemaUID\n  // );\n  // console.log(schema);\n\n  const timestamp = Math.floor(Date.now() / 1000);\n\n  const attestation = await offchain.signOffchainAttestation(\n    {\n      recipient: params.recipient,\n      // Unix timestamp of when attestation expires. (0 for no expiration)\n      expirationTime: BigInt(0),\n      // Unix timestamp of current time\n      time: BigInt(timestamp),\n      revocable: true,\n      version: 1, // Fixed value\n      nonce: BigInt(0), // Fixed value\n      schema: params.schemaUID,\n      refUID: params.refUID,\n      data: params.encodedData,\n    },\n    signer\n  );\n\n  const attestation_ = JSON.stringify(attestation, (key, value) =>\n    typeof value === \"bigint\" ? Number(value).toString() : value\n  );\n\n  return attestation_;\n};\n","// import {BAS, SchemaRegistry} from \"@bnb-attestation-service/bas-sdk\";\nimport { EAS, SchemaRegistry,SchemaRecord } from \"@ethereum-attestation-service/eas-sdk\";\nimport { ethers, Provider, Signer } from \"ethers\";\nimport { BNB_basAddress, GFTESTCHAINID, GFTESTRPC } from \"../../tests/config\";\n\n\nexport const initEAS = (provider: any, BASContractAddress: string) => {\n  const bas = new EAS(BASContractAddress);\n  bas.connect(provider);\n};\n\n/**\n * Register a schema Parameters\n * @param schema The schema string\n * @param resolverAddress The address of the resolver\n * @param revocable Whether the schema is revocable\n */\nexport type RegisterSchemaParams = {\n  schema: string;\n  resolverAddress?: string;\n  revocable?: boolean;\n};\n\n/**\n * Register a schema on the Schema Registry\n * @param signer The signer object\n * @param schemaRegistryAddress The address of the Schema Registry\n * @param params The parameters for the schema\n * @returns The UID of the registered schema\n */\nexport const registerSchema = async (\n  signer: Signer,\n  schemaRegistryAddress: string,\n  params: RegisterSchemaParams\n) => {\n  const schemaRegistry = new SchemaRegistry(schemaRegistryAddress);\n\n  schemaRegistry.connect(signer);\n\n  const transaction = await schemaRegistry.register({\n    schema: params.schema,\n    resolverAddress: params.resolverAddress,\n    revocable: params.revocable,\n  });\n\n  // Optional: Wait for transaction to be validated\n  const schemaUID = await transaction.wait();\n  return schemaUID;\n};\n\n/**\n * Get a schema by its UID\n * @param provider The provider object\n * @param schemaRegistryAddress The address of the Schema Registry\n * @param schemaUID The UID of the schema\n * @returns The schema record\n */\nexport const getSchemaByUID = async (\n  provider: Provider,\n  schemaRegistryAddress: string,\n  schemaUID: string\n):Promise<SchemaRecord> => {\n  const schemaRegistry = new SchemaRegistry(schemaRegistryAddress);\n  schemaRegistry.connect(provider);\n\n  const schemaRecord = await schemaRegistry.getSchema({ uid: schemaUID });\n\n  return schemaRecord;\n};\n"],"names":["getSps","client","Promise","resolve","sp","getStorageProviders","then","sps","filter","v","endpoint","includes","e","reject","selectSp","finalSps","_finalSps$selectIndex","selectIndex","Math","floor","random","length","secondarySpAddresses","concat","slice","map","item","operatorAddress","id","primarySpAddress","sealAddress","rs","ReedSolomon","createFile","fileName","fileBuffer","name","type","size","byteLength","content","GreenFieldClientTS","url","chainId","creator","this","address","Client","create","_proto","prototype","createBucket","bucketName","privateKey","_this","spInfo","_temp3","_temp","_catch","bucket","visibility","VisibilityType","VISIBILITY_TYPE_PUBLIC_READ","chargedReadQuota","Long","fromString","paymentAddress","createBucketTx","simulate","denom","simulateInfo","broadcast","gasLimit","Number","gasPrice","payer","granter","_createBucketTx$broad","console","log","transactionHash","error","isBucketExist","startsWith","_temp2","getBucketMeta","bucketMeta","createObject","attestation","isPrivate","_this2","attest","JSON","parse","message","schema","uid","Buffer","from","expectCheckSums","encode","Uint8Array","object","objectName","VISIBILITY_TYPE_PRIVATE","contentType","redundancyType","RedundancyType","REDUNDANCY_EC_TYPE","payloadSize","fromInt","expectChecksums","x","bytesFromBase64","createObjectTx","_ref","uploadObject","body","txnHash","uploadRes","code","signer","bas","params","connect","getOffchain","offchain","timestamp","Date","now","signOffchainAttestation","recipient","expirationTime","BigInt","time","revocable","version","nonce","schemaUID","refUID","data","encodedData","stringify","key","value","toString","addr","hashMessage","getAddress","substring","_sp$description","description","moniker","provider","schemaRegistryAddress","schemaRegistry","SchemaRegistry","getSchema","BASContractAddress","EAS","register","resolverAddress","transaction","wait"],"mappings":"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"}
{"version":3,"file":"index.js","sources":["../src/greenfield/utils.ts","../src/greenfield/create.ts","../src/bas/index.ts","../src/attestation/createAttestation.ts","../src/schema/register.ts"],"sourcesContent":["import { hashMessage, getAddress } from \"ethers\";\n\n/**\n * encode address to bucket name\n * @param addr\n * @returns bucket name\n */\nexport const encodeAddrToBucketName = (addr: string) => {\n  return `bas-${hashMessage(getAddress(addr)).substring(2, 42)}`;\n};\nexport const getSps = async (client) => {\n  const sps = await client.sp.getStorageProviders();\n  const finalSps = (sps ?? []).filter((v) => v.endpoint.includes(\"nodereal\"));\n  return finalSps;\n};\nexport const getAllSps = async (client) => {\n  const sps = await getSps(client);\n  return sps.map((sp) => {\n    return {\n      address: sp.operatorAddress,\n      endpoint: sp.endpoint,\n      name: sp.description?.moniker,\n    };\n  });\n};\nexport const selectSp = async (client) => {\n  const finalSps = await getSps(client);\n  const selectIndex = Math.floor(Math.random() * finalSps.length);\n  const secondarySpAddresses = [\n    ...finalSps.slice(0, selectIndex),\n    ...finalSps.slice(selectIndex + 1),\n  ].map((item) => item.operatorAddress);\n  const selectSpInfo = {\n    //@ts-ignore\n    id: finalSps[selectIndex].id || 0,\n    endpoint: finalSps[selectIndex].endpoint,\n    primarySpAddress: finalSps[selectIndex]?.operatorAddress,\n    sealAddress: finalSps[selectIndex].sealAddress,\n    secondarySpAddresses,\n  };\n  return selectSpInfo;\n};\n","import {\n  bytesFromBase64,\n  Client,\n  Long,\n  RedundancyType,\n  VisibilityType,\n} from \"@bnb-chain/greenfield-js-sdk\";\nimport { DeliverTxResponse } from \"@cosmjs/stargate\";\nimport { encodeAddrToBucketName, selectSp } from \"./utils\";\nimport { ReedSolomon } from \"@bnb-chain/reed-solomon\";\n// import { NodeAdapterReedSolomon } from \"@bnb-chain/reed-solomon/node.adapter\";\n\nconst rs = new ReedSolomon();\n// const rs = new NodeAdapterReedSolomon();\n\n/**\n * GreenField Client\n */\nexport class GreenFieldClientTS {\n  client: Client;\n  // chainId = null;\n  address = null;\n  /**\n   * @param url greenfield rpc url\n   * @param chainId greenfield chainId\n   * @param creator creator address\n   */\n  constructor(url: string, chainId: string, creator: string) {\n    this.client = Client.create(url, chainId);\n    this.address = creator;\n  }\n\n  /**\n   * create bucket\n   * @param bucketName bucket name\n   * @param privateKey creator private key\n   */\n  async createBucket(bucketName: string, privateKey: string) {\n    const spInfo = await selectSp(this.client);\n    // console.log(\"spInfo\", spInfo);\n\n    if (!privateKey.startsWith(\"0x\")) {\n      privateKey = \"0x\" + privateKey;\n    }\n\n    // Bucket is existed\n    let isBucketExist = false;\n    try {\n      const bucketMeta = await this.client.bucket.getBucketMeta({ bucketName });\n      console.log(\"bucketMeta\", bucketMeta);\n\n      isBucketExist = true;\n    } catch (error) {}\n\n    let res: DeliverTxResponse;\n    try {\n      const createBucketTx = await this.client.bucket.createBucket({\n        bucketName: bucketName,\n        creator: this.address,\n        visibility: VisibilityType.VISIBILITY_TYPE_PUBLIC_READ,\n        chargedReadQuota: Long.fromString(\"0\"),\n        paymentAddress: this.address,\n        primarySpAddress: spInfo.primarySpAddress,\n      });\n      // console.log({ createBucketTx });\n\n      const simulateInfo = await createBucketTx.simulate({\n        denom: \"BNB\",\n      });\n      // console.log(\"simulateInfo\", simulateInfo);\n      res = await createBucketTx.broadcast({\n        denom: \"BNB\",\n        gasLimit: Number(simulateInfo?.gasLimit),\n        gasPrice: simulateInfo?.gasPrice || \"5000000000\",\n        payer: this.address,\n        granter: \"\",\n        privateKey: privateKey,\n      });\n\n      console.log(\"transactionHash\", res.transactionHash);\n    } catch (error) {\n      if (!isBucketExist) {\n        console.log(error);\n      }\n    }\n\n    return isBucketExist;\n  }\n\n  /**\n   * create object\n   * @param bucketName bucket name\n   * @param attestation attestation\n   * @param privateKey creator private key\n   * @param isPrivate is private object\n   */\n  async createObject(\n    bucketName: string,\n    attestation: string,\n    privateKey: string,\n    isPrivate = false\n  ) {\n    console.log(\"started\");\n    // console.log(this.address, this.chainId);\n    if (!privateKey.startsWith(\"0x\")) {\n      privateKey = \"0x\" + privateKey;\n    }\n\n    const attest = JSON.parse(attestation);\n    const fileName = `${attest.message.schema}.${attest.uid}`;\n\n    const fileBuffer = Buffer.from(attestation);\n\n    const expectCheckSums = rs.encode(Uint8Array.from(fileBuffer));\n    // const expectCheckSums = await rs.encodeInWorker(\n    //   __filename,\n    //   Uint8Array.from(fileBuffer)\n    // );\n\n    // createObject\n    const createObjectTx = await this.client.object.createObject({\n      bucketName: bucketName,\n      objectName: fileName,\n      creator: this.address,\n      visibility: isPrivate\n        ? VisibilityType.VISIBILITY_TYPE_PRIVATE\n        : VisibilityType.VISIBILITY_TYPE_PUBLIC_READ,\n      contentType: \"json\",\n      redundancyType: RedundancyType.REDUNDANCY_EC_TYPE,\n      payloadSize: Long.fromInt(fileBuffer.byteLength),\n      expectChecksums: expectCheckSums.map((x) => bytesFromBase64(x)),\n    });\n\n    const simulateInfo = await createObjectTx.simulate({\n      denom: \"BNB\",\n    });\n    // console.log(simulateInfo);\n    const { transactionHash } = await createObjectTx.broadcast({\n      denom: \"BNB\",\n      gasLimit: Number(simulateInfo.gasLimit),\n      gasPrice: simulateInfo.gasPrice,\n      payer: this.address,\n      granter: \"\",\n      privateKey: privateKey,\n    });\n\n    console.log(\"create object success\", transactionHash);\n\n    // uploadObject\n    const uploadRes = await this.client.object.uploadObject(\n      {\n        bucketName: bucketName,\n        objectName: fileName,\n        body: createFile(fileName, fileBuffer),\n        txnHash: transactionHash,\n      },\n      // highlight-start\n      {\n        type: \"ECDSA\",\n        privateKey: privateKey,\n      }\n      // highlight-end\n    );\n    if (uploadRes.code === 0) {\n      console.log(\"upload object success\", uploadRes);\n    }\n\n    return transactionHash;\n  }\n}\nfunction createFile(fileName: string, fileBuffer: Buffer) {\n  return {\n    name: fileName,\n    type: \"\",\n    size: fileBuffer.byteLength,\n    content: fileBuffer,\n  };\n}\n","import {\n  EAS as BaseEAS,\n  SchemaEncoder as BaseSchemaEncoder,\n  MultiAttestationRequest as BaseMultiAttestationRequest,\n  AttestationRequestData as BaseAttestationRequestData,\n} from \"@ethereum-attestation-service/eas-sdk\";\n\nexport const BAS = BaseEAS;\nexport const SchemaEncoder = BaseSchemaEncoder;\nexport type MultiAttestationRequest = BaseMultiAttestationRequest;\nexport type AttestationRequestData = BaseAttestationRequestData;\n","// import { SchemaEncoder, BAS } from \"@bnb-attestation-service/bas-sdk\";\nimport { EAS, SchemaEncoder } from \"@ethereum-attestation-service/eas-sdk\";\nimport { ethers, Signer } from \"ethers\";\nimport { BNB_schemaRegistryAddress } from \"../../tests/config\";\nimport { getSchemaByUID } from \"../schema/register\";\n\n// Initialize SchemaEncoder with the schema string\n\n/**\n * Attestation params\n * @param schemaUID schema uid\n * @param encodedData encoded data\n * @param refUID reference uid\n * @param recipient recipient address\n */\nexport type AttestParams = {\n  schemaUID: string;\n  encodedData: string;\n  refUID: string;\n  recipient: string;\n};\n\n/**\n * Create attestation\n * @param signer signer\n * @param bas bas\n * @param params attestation params\n * @returns attestation string\n */\nexport const createAttestOffChain = async (\n  signer: Signer,\n  bas: EAS,\n  params: AttestParams\n) => {\n  bas.connect(signer);\n\n  const offchain = await bas.getOffchain();\n\n  // const schema = await getSchemaByUID(\n  //   signer.provider,\n  //   BNB_schemaRegistryAddress,\n  //   params.schemaUID\n  // );\n  // console.log(schema);\n\n  const timestamp = Math.floor(Date.now() / 1000);\n\n  const attestation = await offchain.signOffchainAttestation(\n    {\n      recipient: params.recipient,\n      // Unix timestamp of when attestation expires. (0 for no expiration)\n      expirationTime: BigInt(0),\n      // Unix timestamp of current time\n      time: BigInt(timestamp),\n      revocable: true,\n      version: 1, // Fixed value\n      nonce: BigInt(0), // Fixed value\n      schema: params.schemaUID,\n      refUID: params.refUID,\n      data: params.encodedData,\n    },\n    signer\n  );\n\n  const attestation_ = JSON.stringify(attestation, (key, value) =>\n    typeof value === \"bigint\" ? Number(value).toString() : value\n  );\n\n  return attestation_;\n};\n","// import {BAS, SchemaRegistry} from \"@bnb-attestation-service/bas-sdk\";\nimport { EAS, SchemaRegistry,SchemaRecord } from \"@ethereum-attestation-service/eas-sdk\";\nimport { ethers, Provider, Signer } from \"ethers\";\nimport { BNB_basAddress, GFTESTCHAINID, GFTESTRPC } from \"../../tests/config\";\n\n\nexport const initEAS = (provider: any, BASContractAddress: string) => {\n  const bas = new EAS(BASContractAddress);\n  bas.connect(provider);\n};\n\n/**\n * Register a schema Parameters\n * @param schema The schema string\n * @param resolverAddress The address of the resolver\n * @param revocable Whether the schema is revocable\n */\nexport type RegisterSchemaParams = {\n  schema: string;\n  resolverAddress?: string;\n  revocable?: boolean;\n};\n\n/**\n * Register a schema on the Schema Registry\n * @param signer The signer object\n * @param schemaRegistryAddress The address of the Schema Registry\n * @param params The parameters for the schema\n * @returns The UID of the registered schema\n */\nexport const registerSchema = async (\n  signer: Signer,\n  schemaRegistryAddress: string,\n  params: RegisterSchemaParams\n) => {\n  const schemaRegistry = new SchemaRegistry(schemaRegistryAddress);\n\n  schemaRegistry.connect(signer);\n\n  const transaction = await schemaRegistry.register({\n    schema: params.schema,\n    resolverAddress: params.resolverAddress,\n    revocable: params.revocable,\n  });\n\n  // Optional: Wait for transaction to be validated\n  const schemaUID = await transaction.wait();\n  return schemaUID;\n};\n\n/**\n * Get a schema by its UID\n * @param provider The provider object\n * @param schemaRegistryAddress The address of the Schema Registry\n * @param schemaUID The UID of the schema\n * @returns The schema record\n */\nexport const getSchemaByUID = async (\n  provider: Provider,\n  schemaRegistryAddress: string,\n  schemaUID: string\n):Promise<SchemaRecord> => {\n  const schemaRegistry = new SchemaRegistry(schemaRegistryAddress);\n  schemaRegistry.connect(provider);\n\n  const schemaRecord = await schemaRegistry.getSchema({ uid: schemaUID });\n\n  return schemaRecord;\n};\n"],"names":["getSps","client","Promise","resolve","sp","getStorageProviders","then","sps","filter","v","endpoint","includes","e","reject","selectSp","finalSps","_finalSps$selectIndex","selectIndex","Math","floor","random","length","secondarySpAddresses","concat","slice","map","item","operatorAddress","id","primarySpAddress","sealAddress","rs","ReedSolomon","GreenFieldClientTS","url","chainId","creator","this","address","Client","create","_proto","prototype","createBucket","bucketName","privateKey","_this","spInfo","_temp3","_temp","_catch","bucket","visibility","VisibilityType","VISIBILITY_TYPE_PUBLIC_READ","chargedReadQuota","Long","fromString","paymentAddress","createBucketTx","simulate","denom","simulateInfo","broadcast","gasLimit","Number","gasPrice","payer","granter","_createBucketTx$broad","console","log","transactionHash","error","isBucketExist","startsWith","_temp2","getBucketMeta","bucketMeta","createObject","attestation","isPrivate","_this2","attest","JSON","parse","fileName","message","schema","uid","fileBuffer","Buffer","from","expectCheckSums","encode","Uint8Array","object","objectName","VISIBILITY_TYPE_PRIVATE","contentType","redundancyType","RedundancyType","REDUNDANCY_EC_TYPE","payloadSize","fromInt","byteLength","expectChecksums","x","bytesFromBase64","createObjectTx","_ref","uploadObject","body","createFile","txnHash","type","uploadRes","code","name","size","content","SchemaEncoder","BaseSchemaEncoder","BaseEAS","EAS","signer","bas","params","connect","getOffchain","offchain","timestamp","Date","now","signOffchainAttestation","recipient","expirationTime","BigInt","time","revocable","version","nonce","schemaUID","refUID","data","encodedData","stringify","key","value","toString","addr","hashMessage","getAddress","substring","_sp$description","description","moniker","provider","schemaRegistryAddress","schemaRegistry","SchemaRegistry","getSchema","BASContractAddress","register","resolverAddress","transaction","wait"],"mappings":"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"}